schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
scalar Date
enum CardNetwork {
  visa
  mastercard
}
type Card {
  """The ID of the payment"""
  id: ID!
  """The date at witch the payment was created"""
  createdAt: Date!
  """The date at witch the payment was last updated"""
  updatedAt: Date!
  circleCardId: ID!
  ownerId: ID!
  metadata: CardMetadata
  verification: CardVerification
}
type CardMetadata {
  digits: String
  network: CardNetwork
  billingDetails: CardBillingDetails
}
type CardVerification {
  cvv: String
}
type CardBillingDetails {
  name: String
  city: String
  country: String
  postalCode: String
  district: String
  line1: String
}
type User {
  id: ID!
  firstName: String
  lastName: String
  email: String
  photoURL: String
  createdAt: Date
  tokens: [String]
  permissions: [String]
  proposals(page: Int = 1): [Proposal]
  subscriptions(page: Int = 1, status: SubscriptionStatus): [Subscription]
}
type Wire {
  """The local ID of the payout"""
  id: ID!
  createdAt: Date
  updatedAt: Date
  description: String
  bank: WireBank
  billingDetails: WireBillingDetailsType
}
type WireBank {
  bankName: String
  city: String
  country: String
}
type WireBillingDetailsType {
  city: String
  country: String
  line1: String
  line2: String
  name: String
  postalCode: String
}
enum EventType {
  commonCreated
  commonCreationFailed
  commonWhitelisted
  commonMemberAdded
  commonMemberRemoved
  commonUpdated
  requestToJoinCreated
  requestToJoinAccepted
  requestToJoinRejected
  requestToJoinExecuted
  fundingRequestCreated
  fundingRequestRejected
  fundingRequestExecuted
  fundingRequestAccepted
  fundingRequestAcceptedInsufficientFunds
  voteCreated
  paymentCreated
  paymentConfirmed
  paymentFailed
  paymentPaid
  payoutCreated
  payoutApproved
  payoutExecuted
  payoutVoided
  payoutCompleted
  payoutFailed
  cardCreated
  discussionCreated
  messageCreated
  subscriptionCreated
  subscriptionPaymentCreated
  subscriptionPaymentFailed
  subscriptionPaymentConfirmed
  subscriptionPaymentStuck
  subscriptionCanceledByUser
  subscriptionCanceledByPaymentFailure
  membershipRevoked
}
type Event {
  """The unique identifier of the event"""
  id: ID!
  """The type of the event"""
  type: EventType!
  """The date, at which the event was created"""
  createdAt: Date!
  """The date, at which the event was last updated"""
  updatedAt: Date!
  """The id of the object on which was acted to created the event"""
  objectId: ID
  """The id of the actor"""
  userId: ID
  user: User
}
enum CommonContributionType {
  oneTime
  monthly
}
type CommonMember {
  """The user ID of the member"""
  userId: ID!
  """The date, at witch the member joined the common"""
  joinedAt: Date
  user: User
}
type CommonMetadata {
  byline: String!
  description: String!
  founderId: String!
  minFeeToJoin: Int!
  contributionType: CommonContributionType
}
type Payout {
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  circlePayoutId: String
  amount: Int!
  executed: Boolean
  voided: Boolean
  status: PayoutStatus
  security: [PayoutSecurity]
  proposalIds: [String]
  proposals: [Proposal]
}
type PayoutSecurity {
  id: Int
  redemptionAttempts: Int
  redeemed: Boolean
}
enum PayoutStatus {
  pending
  complete
  failed
}
input ExecutePayoutInput {
  """The ID of the the wire to witch the payout will be made"""
  wireId: ID!
  """List of the all proposals IDs that are in this batch"""
  proposalIds: [ID!]!
}
enum PaymentType {
  oneTime
  subscription
}
enum PaymentSourceType {
  card
}
enum PaymentStatus {
  pending
  confirmed
  paid
  failed
}
enum PaymentCurrency {
  USD
}
type Payment {
  """The ID of the payment"""
  id: ID!
  """The date at witch the payment was created"""
  createdAt: Date!
  """The date at witch the payment was last updated"""
  updatedAt: Date!
  type: PaymentType!
  status: PaymentStatus!
  """The source from witch the payment was funded"""
  source: PaymentSource!
  amount: PaymentAmount!
  """The fees on the payment"""
  fees: PaymentFees
  circlePaymentId: ID!
  proposalId: ID!
  userId: ID!
  subscriptionId: ID
  user: User
  card: Card
  common: Common
  proposal: Proposal
  subscription: Subscription
}
type PaymentFees {
  amount: Int
  currency: PaymentCurrency
}
type PaymentSource {
  type: PaymentSourceType!
  id: ID
}
type PaymentAmount {
  currency: PaymentCurrency
  amount: Int
}
enum ProposalType {
  fundingRequest
  join
}
enum ProposalState {
  passedInsufficientBalance
  countdown
  passed
  failed
}
enum ProposalVoteOutcome {
  approved
  rejected
}
enum ProposalPaymentState {
  notAttempted
  notRelevant
  confirmed
  pending
  failed
}
enum ProposalFundingState {
  notRelevant
  notAvailable
  available
  funded
}
"""The proposals type"""
type Proposal {
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  commonId: ID!
  proposerId: ID!
  votesFor: Int!
  votesAgainst: Int!
  state: ProposalState!
  description: ProposalDescription!
  type: ProposalType!
  paymentState: ProposalPaymentState
  fundingState: ProposalFundingState
  """Details about the funding request. Exists only on funding request proposals"""
  fundingRequest: ProposalFunding
  """Details about the join request. Exists only on join request proposals"""
  join: ProposalJoin
  votes: [ProposalVote]
  common: Common!
  proposer: User!
}
type ProposalDescription {
  title: String
  description: String!
}
type ProposalFunding {
  amount: Int!
}
type ProposalJoin {
  cardId: ID!
  funding: Int!
  fundingType: CommonContributionType
}
type ProposalVote {
  voteId: ID!
  voterId: ID!
  outcome: ProposalVoteOutcome!
  voter: User
}
type Intention {
  id: ID!
  createdAt: Date!
  updatedAt: Date!
  type: IntentionType!
  intention: String!
}
enum IntentionType {
  access
  request
}
input CreateIntentionInput {
  type: IntentionType!
  intention: String!
}
enum SubscriptionStatus {
  pending
  active
  canceledByUser
  canceledByPaymentFailure
  paymentFailed
}
type Subscription {
  id: ID!
  cardId: ID!
  userId: ID!
  proposalId: ID!
  createdAt: Date!
  updatedAt: Date!
  charges: Int!
  amount: Int!
  lastChargedAt: Date
  dueDate: Date
  revoked: Boolean!
  status: SubscriptionStatus!
  metadata: SubscriptionMetadata!
}
type SubscriptionMetadata {
  common: SubscriptionMetadataCommon
}
type SubscriptionMetadataCommon {
  id: ID
  name: String
}
type Statistics {
  """Commons, created on that date"""
  newCommons: Int
  """The amount of proposals with join type, created on that date"""
  newJoinRequests: Int
  """The amount of proposals with funding type, created on that date"""
  newFundingRequests: Int
  """The amount of discussions, started on that date"""
  newDiscussions: Int
  """The amount of new discussion messages, send on that date"""
  newDiscussionMessages: Int
  commons: Int
  joinRequests(onlyOpen: Boolean = false): Int
  fundingRequests(onlyOpen: Boolean = false): Int
  users: Int
}
"""The common type"""
type Common {
  """The unique identifier of the common"""
  id: ID!
  """The date, at which the common was created"""
  createdAt: Date
  """The date, at which the common was last updated"""
  updatedAt: Date
  """The display name of the common"""
  name: String!
  """The currently available funds of the common"""
  balance: Int!
  """The total amount of money, raised by the common"""
  raised: Int!
  metadata: CommonMetadata!
  members: [CommonMember]
  proposals(page: Int, type: ProposalType, state: ProposalState, paymentState: ProposalPaymentState): [Proposal]
  openJoinRequests: Int!
  openFundingRequests: Int!
}
type Query {
  user(id: ID!): User
  users(page: Int = 1, perPage: Int = 10): [User]
  wires(page: Int = 1): [Wire]
  event(eventId: ID!): Event
  events(last: Int = 10, after: Int = 0, type: EventType, objectId: ID): [Event]
  common(
    """The ID of the common, that you want to retrieve"""
    commonId: ID!
  ): Common
  commons(last: Int = 10, after: Int = 0): [Common]
  payout(id: ID!): Payout
  payouts(page: Int = 1): [Payout]
  payment(id: ID!): Payment
  payments(page: Int = 1, hanging: Boolean): [Payment]
  proposal(id: ID!): Proposal
  proposals(ids: [String], page: Int = 1, pageItems: Int = 10, type: ProposalType, fundingState: ProposalFundingState): [Proposal]
  statistics: Statistics
}
type Mutation {
  whitelistCommon(commonId: ID!): Boolean
  """Refresh the common members from the events. Returns the new common member count"""
  refreshCommonMembers(
    """The common id to refresh"""
    commonId: ID!
  ): Int
  executePayouts(input: ExecutePayoutInput!): Payout
  updatePaymentData(id: ID!, trackId: ID = "fbb61190-d465-4395-9136-3d643a717033"): Boolean
  createIntention(input: CreateIntentionInput!): Intention
}